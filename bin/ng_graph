#!/usr/bin/env python3.6
# ng_graph.py
"""Script for generating graphs from ng_trajectory files.
"""
######################
# Imports & Globals
######################

import sys, os, argparse

# It is possible to do it using the library, but we skip on this now
# to actually do not require all dependencies + speed up the process.
#import ng_trajectory
import json

import statistics

from typing import List, Dict, Generator, TextIO


# Global variables
PARSER = argparse.ArgumentParser(
    prog = "ng_graph",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description = """
Script for generating graphs from ng_trajectory files.

When using a '.json' configuration file we expect that the logs
are in the same location.
    """,
)

# Arguments
PARSER.add_argument("input_file",
    help = "Path to the ng_trajectory file.",
    type = argparse.FileType("r"),
)

PARSER.add_argument("-v",
    dest = "verbose",
    help = "Give more output.",
    action = "store_true",
)

PARSER.add_argument("-l",
    dest = "logfile",
    help = "Treat the input file as a log file.",
    action = "store_true",
)


######################
# Log class
######################

class Log(object):

    def __init__(self, filename: str = "", filestream: TextIO = None):
        super(Log, self).__init__()

        self.__filename = filename
        self.__parts = {}
        self.__others = []

        if filename != "":
            with open(filename, "r") as f:
                self.load_data(f)
        else:
            self.load_data(filestream)


        # And now for the preprocessing
        self.__penalty = [ float(_p) for _p in self.__parts.get("penalty", []) ]
        self.__correct = [ float(_c) for _c in self.__parts.get("correct", []) ]

        # Best solution is repeated once again at the end
        if len(self.__correct) > 0:
            self.__correct = self.__correct[:-1]
        else:
            self.__penalty = self.__penalty[:-1]


    def load_data(self, f: TextIO):
        for _li, line in enumerate(f):

            # Configuration
            if _li == 0:
                if line[0] == "{":
                    self.__configuration = line

            # Important parts
            if ":" in line:
                part = line.split(":")[0]

                if part not in self.__parts:
                    self.__parts[part] = []

                self.__parts[part].append(line[(line.index(":")+1):-1])

            # The rest
            else:
                self.__others.append(line)


    def add(self, other):
        """Merge two logs by adding data from the other to self."""

        self.__correct += other.__correct
        self.__penalty += other.__penalty


    def __str__(self):
        s = ""

        # Filename
        s += "Log: %s\n" % self.__filename

        # Others
        s += "Others: %s\n" % "\n".join(self.__others)

        # Success rate
        s += "Success rate: %f%% (%d out of %d)\n" % (
            100.0 * len(self.__correct) / (len(self.__penalty) + len(self.__correct)),
            len(self.__correct),
            len(self.__correct) + len(self.__penalty)
        )

        # Statistics
        if len(self.__correct) > 0:
            s += "Solution statistics:\n\t" + "\n\t".join([
                "Min: %f" % min(self.__correct),
                "Avg: %f" % statistics.mean(self.__correct),
                "Max: %f" % max(self.__correct),
                "Std: %f" % statistics.stdev(self.__correct),
            ]) + "\n"

        return (s)


######################
# Log files
######################

def construct_log_names(
    configuration: Dict[str, any]
    ) -> Dict[str, any]:
    """Construct all names of the logs according to the configuration.

    The dictionary is created as:
    - variate (if applicable)
      - loops
        - cascade steps
          - name of the log

    Note: Yes, it is quite ugly, but this is currently the best (and simplest?)
          way to do it.
    """

    ## a) Check for prefix
    if "prefix" not in configuration:
        print ("Selected configuration does not create logs. Add 'prefix' parameter to create them.", file = sys.stderr)
        exit (4)

    _prefix = configuration.get("prefix")

    ## b) Check for variate
    _variate = configuration.get(configuration.get("variate")) if "variate" in configuration else []

    ## c) Get loops
    _loops = configuration.get("loops")

    ## d) Get cascade
    _cascade = configuration.get("cascade")


    lognames = {}
    filename = "%s" % _prefix

    if _variate == []:
        lognames[""] = construct_log_names_variate(
            filename,
            _loops,
            _cascade,
            configuration.get("algorithm", "")
        )
    else:
        if all([ isinstance(_value, int) for _value in _variate ]):
            variate_suffix = "%%0%dd" % len(str(max(_variate)))
        else:
            variate_suffix = "%s"

        for value in _variate:
            lognames[variate_suffix % value] = construct_log_names_variate(
                filename + "-" + variate_suffix % value,
                _loops,
                _cascade,
                value if configuration.get("variate") == "algorithm" else configuration.get("algorithm", "")
            )

    return lognames


def construct_log_names_variate(
        filename: str,
        loops: int,
        cascade: List[Dict[str, any]],
        algorithm: str = "",
    ) -> Dict[str, any]:

    lognames = {}

    loops_suffix = "%%0%dd" % len(str(loops))

    for loop in range(loops):
        current_loop = loops_suffix % (loop + 1)

        lognames[current_loop] = {}

        cascade_suffix = "%%0%dd" % len(str(len(cascade)))

        for _i, step in enumerate(cascade):
            current_step = cascade_suffix % (_i + 1)

            lognames[current_loop][current_step] = filename + "-" + current_loop + "-" + current_step + "-%s.log" % step.get("algorithm", algorithm)

    return lognames


######################
# Main
######################

if __name__ == "__main__":

    # Obtain arguments
    args = PARSER.parse_args()

    if not args.logfile:
        # Load configuration
        configuration = json.loads(args.input_file.read())

        # Construct names of all expected files
        log_names = construct_log_names(configuration)

    else:
        print( Log(filestream = args.input_file) )

    pass
